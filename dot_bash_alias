# -*- ft: bash -*-
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"
[ -x ~/bin/fzf ] && alias fzf='~/bin/fzf'
alias L='less -R --use-color' # most?
alias G='grep --color=always -i'
alias ls='ls --color=auto'
alias lls='ls -lAGh1vX --group-directories-first --color=always | L'
alias lastCommand='history 2 | head -1 | awk \!\(\$1\=\"\"\)'
backup() { cp -a "${1}" "${1}_$(date +%Y%m%d_%H%M%S)"; }

alias docker-top='ctop'
alias docker-prune='docker image prune -a -f && docker volume prune -f && docker system prune -a -f'
alias docker-clean-images='docker images -q -f dangling=true | xargs docker rmi'
alias docker-clean-containers='docker rm $(docker ps -a -q)'
alias docker-run='docker run --rm -it'
alias docker-logs='docker-compose logs -f --tail 100'
docker-netshoot() { docker run -it --net container:$1 nicolaka/netshoot; }
docker-shell() { docker exec -it $1 /bin/bash -l -O vi; }
alias kg='kubectl neat get --'
kubectl-netshoot() { kubectl debug $1 -it --image=nicolaka/netshoot; }
alias kl='stern'
alias dfh='duf -hide special'
alias hl='rg --passthru --color=always'

if _command_exists zoxide; then
    eval "$(zoxide init --cmd j bash)"
else
    alias j=cd
fi

if _command_exists hwatch; then
    alias watch='hwatch -c -d word --no-help-banner --no-title -n 1'; fi
if _command_exists doggo; then
    alias dig='doggo'; fi

if _command_exists procs; then
    alias psw='procs'
    alias pswg='procs'
else
    alias psw='ps auxww'
    pswg() { ps auxww | G $1 | grep -v grep; }
fi

if _command_exists gtop; then
    alias htop='gtop'
elif _command_exists btm; then
    alias htop='btm'
elif _command_exists bpytop; then
    alias htop='bpytop'
elif _command_exists glances; then
    alias htop='glances'
fi

if _command_exists xh; then
    alias http='xh'
elif _command_exists httpie; then
    alias http='httpie'
elif _command_exists curlie; then
    alias http='curlie'
else
    alias http='curl'
fi

# chezmoi
alias chezmoi-pull='chezmoi git pull -- --autostash --rebase && chezmoi diff' # TODO: add prompt to autoapply
function chezmoi-new-ubuntu {
    echo curl -sSL https://raw.githubusercontent.com/junegunn/fzf/refs/heads/master/install \| bash
    echo sh -c \"\$\(curl -fsLS get.chezmoi.io\)\" -- init --apply yunake
    echo 'sudo apt install -y bpytop tmux ripgrep exuberant-ctags'
}
function chezmoi-new-ubuntu-broken-escaping {
    ssh "$@" bash -c 'sh -c '"$(curl -fsLS get.chezmoi.io)" -- init --apply https://github.com/yunake/dotfiles.git''
}

# TODO: modify it so it opens PDFs, or white custom script like ~/bin/rfv
# better yet, `mv rfv search` and make it open most files in vim, pdf via `open`, or patch rga-fzf / ripgrep-all
alias search_pdf='rga-fzf'

function ips() {
	if _command_exists ifconfig; then
		ifconfig | awk '/inet /{ gsub(/addr:/, ""); print $2 }'
	elif _command_exists ip; then
		ip addr | grep -oP 'inet \K[\d.]+'
	fi
}

function myip() {
	list=("http://myip.dnsomatic.com/" "http://checkip.dyndns.com/" "http://checkip.dyndns.org/")
	for url in "${list[@]}"; do
		if res="$(curl -fs "${url}")"; then
			break
		fi
	done
	res="$(echo "$res" | grep -Eo '[0-9\.]+')"
	echo -e "Your public IP is: ${echo_bold_green-} $res ${echo_normal-}"
}

# open files in directory in vim. `:qa` to quit
function vimd {
    #fd "$@" -t f -p0 | xargs -0o vim
    rg --files --sortr=modified -0 | xargs -0o vim
}

function rgd {
    rg --json -C 2 "$@" | delta
}

# preserves last occurance
function dedup {
   tac "$@" | awk '! x[$0]++' | tac
}
# remove "column", leaves IFS behind
function rmcol {
    awk "!(\$$1=\"\")"
}

function taillog {
    tail -f "$@" | bat --paging=never -l log
}


# This script was automatically generated by the broot program
# More information can be found in https://github.com/Canop/broot
# This function starts broot and executes the command
# it produces, if any.
# It's needed because some shell commands, like `cd`,
# have no useful effect if executed in a subshell.
function br {
    local cmd cmd_file code
    cmd_file=$(mktemp)
    if broot --outcmd "$cmd_file" "$@"; then
        cmd=$(<"$cmd_file")
        command rm -f "$cmd_file"
        eval "$cmd"
    else
        code=$?
        command rm -f "$cmd_file"
        return "$code"
    fi
}

